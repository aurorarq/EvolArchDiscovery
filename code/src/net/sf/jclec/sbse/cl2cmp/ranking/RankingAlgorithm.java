package net.sf.jclec.sbse.cl2cmp.ranking;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.configuration.Configuration;
import org.apache.commons.configuration.ConfigurationException;

import es.uco.kdis.datapro.exception.IllegalFormatSpecificationException;
import es.uco.kdis.datapro.exception.NotAddedValueException;
import net.sf.jclec.IConfigure;
import net.sf.jclec.IFitness;
import net.sf.jclec.IIndividual;
import net.sf.jclec.ISelector;
import net.sf.jclec.algorithm.PopulationAlgorithm;
import net.sf.jclec.sbse.cl2cmp.Cl2CmpMutator;
import net.sf.jclec.sbse.cl2cmp.Cl2CmpIndividual;
import net.sf.jclec.sbse.cl2cmp.Cl2CmpSpecies;
import net.sf.jclec.selector.BettersSelector;
import net.sf.jclec.selector.RandomSelector;
import net.sf.jclec.selector.RouletteSelector;
import net.sf.jclec.selector.TournamentSelector;
import net.sf.jclec.base.AbstractMutator;
import net.sf.jclec.fitness.SimpleValueFitness;

/**
 * Algorithm for 'Classes to Components' (Cl2Cmp) problem.
 * @author Aurora Ramirez Quesada
 * @author Jose Raul Romero
 * @author Sebastian Ventura
 * @version 2.0
 * History:
 * <ul>
 * 	<li>1.0: Creation (January 2013)
 * 	<li>2.0: Add selector and replacement strategy for parameter tuning. (September 2013)
 * </ul>
 * */
public class RankingAlgorithm extends PopulationAlgorithm {

	//////////////////////////////////////////////////////////////////
	//----------------------------------------------------- Properties
	//////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	private static final long serialVersionUID = 4778868270360537444L;

	/** Individual's mutator */
	protected AbstractMutator baseMutator;

	/** Frequency of sizes (number of components, 
	 * types of solutions) in individuals */
	protected int [] componentsFreq;

	/** Frequency of sizes (number of components, 
	 * types of solutions) in offsprings */
	private int [] componentsMutFrequency;

	/** Minimum number of components */
	protected int minNumberOfComponents;

	/** Maximum number of components */
	protected int maxNumberOfComponents;

	/** Selector */
	private ISelector selector;

	/** Initial date time */
	private long initTime;

	/** Final date time */
	private long endTime;

	/** Number of offsprings in the actual generation */
	protected int numberOfActualOffsprings;

	/** Number of invalids in the actual generation */
	protected int numberOfInvalids;

	/** Total number of invalids in the overall evolution */
	protected int totalInvalids;

	/** Type of replacement strategy
	 * <ul><li> 1: N best individuals</li>
	 * <li>2: Best between parent and son</li>
	 * <li>3: Elitism (1) + best descendants</li>
	 * <li>4: Elitism (%) + best descendants</li>
	 * <li>5: Binary tournament (without repeat)</li>
	 * </ul>
	 *  */
	private int replacementType;

	/** Type of selector
	 * <ul><li> 1: EP</li>
	 * <li>2: tournament</li>
	 * <li>3: roulette</li>
	 *  */
	private int selectorType;

	//////////////////////////////////////////////////////////////////
	//--------------------------------------------------- Constructors
	//////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 * */
	public RankingAlgorithm(){
		super();
	}

	//////////////////////////////////////////////////////////////////
	//----------------------------------------------- Override methods
	//////////////////////////////////////////////////////////////////

	@Override
	public void configure(Configuration settings) {
		// Call super.configure() method
		super.configure(settings);
		try {
			// Configure datasets in species and evaluator
			String dataset = settings.getString("evaluator.model.path");
			int numOfClasses = settings.getInt("evaluator.model.num-of-classes");
			if(dataset!=null){
				setDatasetInSpecies(dataset, numOfClasses);
			}
			else
				System.err.println("A dataset must be specified");
			// Configure species constraints
			setSpeciesConstraints(settings.subset("species"), numOfClasses);
			// Configure mutators
			setMutatorSettings(settings.subset("base-mutator"));
			// Configure selectors
			setSelectorSettings(settings.subset("parents-selector"));
			// Configure replacement strategy
			this.replacementType=settings.getInt("replacement-strategy",2);

		} catch (Exception e) {
			if(e instanceof IndexOutOfBoundsException)
				System.err.println("Malformed dataset.");
			else if(e instanceof IOException)
				System.err.println("Can't open the dataset.");
			else if(e instanceof NotAddedValueException)
				System.err.println("Some values can't be added to the dataset.");
			else if(e instanceof ConfigurationException)
				System.err.println("Configuration error.");
			else if(e instanceof IllegalFormatSpecificationException)
				System.err.println("Not valid format: the number of classes does not match with the dataset columns");
			else if(e instanceof IllegalArgumentException){
				System.err.print("Illegal argument: " + e.getMessage());
			}
			e.printStackTrace();
			System.exit(1);
		}

		// Initialize internal variables
		int size = this.maxNumberOfComponents-this.minNumberOfComponents+1;
		this.componentsFreq = new int [size];
		this.componentsMutFrequency = new int [size];
	}

	@Override
	protected void doInit() {

		this.initTime=System.currentTimeMillis();

		// Create individuals
		this.bset = this.provider.provide(this.populationSize);

		// Evaluate individuals
		((RankingEvaluator)this.evaluator).setInvalidFitness(this.populationSize);
		this.evaluator.evaluate(this.bset);

		//long providerTime = System.currentTimeMillis();
		//System.out.println("Init: " + (providerTime-this.initTime) + " miliseconds");

		// Verbose
		// Count number of components frequency
		int index;
		for(int i=0; i< this.componentsFreq.length; i++)
			this.componentsFreq[i]=0;
		for(IIndividual ind: this.bset){
			index = ((Cl2CmpIndividual)ind).getNumberOfComponents();
			this.componentsFreq[index-minNumberOfComponents]++;
		}

		// Get number of invalids
		this.numberOfInvalids = 0;
		for(IIndividual ind: this.bset){
			if(((Cl2CmpIndividual)ind).isInvalid())
				this.numberOfInvalids++;
		}
		this.totalInvalids += this.numberOfInvalids;

		// Do Control
		doControl();
	}

	@Override
	protected void doSelection() {

		// Selector has not been configured, then use a deterministic selector
		if(selector == null)
			this.pset = this.bset;

		// Parent selector
		else{

			if(selectorType == 2)
				this.pset = this.selector.select(this.bset,this.populationSize);

			else if (selectorType == 3){	// Roulette -> invert fitness
				List<IIndividual> auxbset = new ArrayList<IIndividual>();

				// Copy individuals
				for(IIndividual ind: this.bset)
					auxbset.add(ind.copy());

				// Invert fitness function
				double fitness;
				for(int i=0; i<populationSize; i++){
					fitness = ((SimpleValueFitness)this.bset.get(i).getFitness()).getValue();
					auxbset.get(i).setFitness(new SimpleValueFitness(1/fitness));
				}

				// Select parents
				List<IIndividual> auxpset = this.selector.select(auxbset, this.populationSize);

				// Recover original parents from bset
				this.pset = new ArrayList<IIndividual>();
				for(IIndividual ind: auxpset){
					this.pset.add(getIndividualById(this.bset,((RankingIndividual)ind).getId()));
				}	
			}
		}
	}

	@Override
	protected void doGeneration() {

		// Mutate individuals and evaluate the population (parents + offsprings)
		this.cset = this.baseMutator.mutate(this.pset);

		List<IIndividual> allSet = new ArrayList<IIndividual>(this.pset);
		allSet.addAll(this.cset);
		this.evaluator.evaluate(allSet);

		// Verbose
		int index;
		for(int i=0; i< this.componentsFreq.length; i++)
			this.componentsMutFrequency[i]=0;

		for(IIndividual ind: this.cset){
			index = ((Cl2CmpIndividual)ind).getNumberOfComponents();
			this.componentsMutFrequency[index-minNumberOfComponents]++;
		}
	}

	@Override
	protected void doReplacement() {

		switch(this.replacementType){
		case 1: 
			this.rset = betterIndividuals();
			break;
		case 2:	
			this.rset = parentSonCompetition();
			break;
		case 3:	
			this.rset = elitismBestSons(1);
			break;
		case 4: 
			this.rset = elitismBestSons((int)(this.populationSize*0.1));
			break;
		case 5: 
			this.rset = binaryTournament();
			break;
		}		
	}

	@Override
	protected void doUpdate() {

		// Update next population
		this.bset.clear();
		this.bset.addAll(this.rset);

		// Reassign ids in bset (actually its not needed if competition between parent and offspring
		// is the replacement strategy)
		for(int i=0; i<this.populationSize; i++)
			((RankingIndividual)this.bset.get(i)).setId(i);

		// Verbose
		int index;
		for(int i=0; i< this.componentsFreq.length; i++)
			this.componentsFreq[i]=0;
		for(IIndividual ind: this.bset){
			index = ((Cl2CmpIndividual)ind).getNumberOfComponents();
			this.componentsFreq[index-minNumberOfComponents]++;
		}

		// Get number of invalids
		this.numberOfInvalids = 0;
		for(IIndividual ind: this.bset){
			if(((Cl2CmpIndividual)ind).isInvalid())
				this.numberOfInvalids++;
		}
		this.totalInvalids += this.numberOfInvalids;

		// Get number of new offsprings
		this.numberOfActualOffsprings = ((Cl2CmpMutator)this.baseMutator).getActualOffspring();

		// Clear population sets
		this.pset = null;
		this.cset = null;
		this.rset.clear();
		this.endTime=System.currentTimeMillis();
	}

	@Override
	protected void doControl(){

		// Maximum number of generations is exceeded
		if (generation >= maxOfGenerations) {
			state = FINISHED;
			return;
		}
		// Maximum number of evaluations is exceeded
		if (evaluator.getNumberOfEvaluations() >= maxOfEvaluations) {
			state = FINISHED;
			return;
		}
		this.endTime=System.currentTimeMillis();
	}

	//////////////////////////////////////////////////////////////////
	//------------------------------------------------- Public methods
	//////////////////////////////////////////////////////////////////

	/**
	 * Get the frequency of each type of 
	 * solutions (by number of components)
	 * for actual population
	 * @return components frequency array
	 * from minimum to maximum
	 * */
	public int[] getComponentsFrecuency() {
		return componentsFreq;
	}

	/**
	 * Get the frequency of each type of 
	 * solutions (by number of components)
	 * for offsprings
	 * @return components frequency array
	 * from minimum to maximum
	 * */
	public int[] getComponentsMutFrecuency() {
		return componentsMutFrequency;
	}

	/**
	 * Get minimum number of components
	 * @return minimum number of components
	 * */
	public int getMinNumberOfComponents(){
		return this.minNumberOfComponents;
	}

	/**
	 * Get maximum number of components
	 * @return maximum number of components
	 * */
	public int getMaxNumberOfComponents(){
		return this.maxNumberOfComponents;
	}

	/**
	 * Get mutator
	 * @return The mutator
	 * */
	public AbstractMutator getMutator(){
		return this.baseMutator;
	}

	/**
	 * Get number of new offsprings
	 * in the current generation
	 * @return number of offsprings
	 * */
	public int getNumberOfOffsprings(){
		return this.numberOfActualOffsprings;
	}

	/**
	 * Get number of new invalid
	 * individuals in the current generation
	 * @return number of invalids
	 * */
	public int getNumberOfInvalids(){
		return this.numberOfInvalids;
	}

	/**
	 * Get total number of valid solution evaluated
	 * @return number of invalids
	 * */
	public int getNumberOfSolutions(){
		return ((this.populationSize*this.maxOfGenerations)-this.totalInvalids);
	}

	/**
	 * Get the execution time
	 * */
	public long getTime(){
		return (this.endTime-this.initTime);
	}

	/** 
	 * Get replacement strategy type
	 * @return Type of replacement
	 * */
	public int getReplacementType(){
		return this.replacementType;
	}

	/** 
	 * Get selector strategy type
	 * @return Type of selector
	 * */
	public int getSelectorType(){
		return this.selectorType;
	}

	//////////////////////////////////////////////////////////////////
	//------------------------------------------------ Private methods
	//////////////////////////////////////////////////////////////////

	/**
	 * Set dataset configuration in species
	 * @param dataset: the path of the dataset
	 * @param numOfClasses: The number of classes in the design
	 * @throws IllegalFormatSpecificationException
	 * @throws IOException
	 * @throws NotAddedValueException
	 * @throws IllegalFormatSpecificationException
	 * */
	private void setDatasetInSpecies(String dataset, int numOfClasses) 
			throws IndexOutOfBoundsException, IOException, NotAddedValueException, IllegalFormatSpecificationException{
		((Cl2CmpSpecies)this.getSpecies()).setDataset(dataset, numOfClasses);
	}

	/**
	 * Set constraints configuration in species
	 * @param settings: the configuration object
	 * @param numOfClasses: The number of classes in the design
	 * */
	private void setSpeciesConstraints(Configuration settings, int numOfClasses){
		this.minNumberOfComponents = settings.getInt("min-of-components", 2);
		this.maxNumberOfComponents = settings.getInt("max-of-components", numOfClasses);
		((Cl2CmpSpecies)this.getSpecies()).setConstraints(this.minNumberOfComponents, this.maxNumberOfComponents);

		// Check the compatibility between classes and components
		if(this.minNumberOfComponents<2 || this.maxNumberOfComponents>numOfClasses)
			throw new IllegalArgumentException("Illegal limits for number of components");
	}

	/**
	 * Set mutation configuration
	 * @param settings: the configuration object
	 * @throws InstantiationException
	 * @throws IllegalAccessExceptionl
	 * @throws ClassNotFoundException
	 * */
	@SuppressWarnings("unchecked")
	private void setMutatorSettings(Configuration settings) 
			throws InstantiationException, IllegalAccessException, ClassNotFoundException{

		// Mutation class instantiation
		String classname = settings.getString("[@type]");
		Class<? extends AbstractMutator> mutatorClass = 
				(Class<? extends AbstractMutator>) Class.forName(classname);
		this.baseMutator = mutatorClass.newInstance();
		// Contextualize
		this.baseMutator.contextualize(this);

		// Configure
		if (this.baseMutator instanceof IConfigure) {
			((IConfigure) this.baseMutator).configure(settings);
		}
	}

	/**
	 * Set selector configuration
	 * @param settings: Configuration
	 * @throws IllegalAccessException 
	 * @throws InstantiationException 
	 * @throws ClassNotFoundException 
	 * */

	@SuppressWarnings("unchecked")
	private void setSelectorSettings(Configuration settings) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
		// Parents selector
		String parentsSelectorClassname = 
				settings.getString("[@type]");

		// Selector can not be specified (default selector is deterministic selector)
		if(parentsSelectorClassname != null){
			Class<? extends ISelector> parentsSelectorClass = 
					(Class<? extends ISelector>) Class.forName(parentsSelectorClassname);
			// Species instance
			ISelector parentsSelector = parentsSelectorClass.newInstance();
			// Configure species if necessary
			if (parentsSelector instanceof IConfigure) {
				// Configure selector
				((IConfigure) parentsSelector).configure(settings);
			}
			// Set selector
			this.selector = parentsSelector;
			//Contextualize
			this.selector.contextualize(this);

			if(this.selector instanceof TournamentSelector)
				this.selectorType = 2;
			else if(this.selector instanceof RouletteSelector)
				this.selectorType = 3;
		}

		else // EP
			this.selectorType = 1;
	}

	/**
	 * Get the individual with the specified id in the list
	 * @param inds: Individuals list
	 * @param id: required id
	 * @return Individual with the id
	 * */
	private IIndividual getIndividualById(List<IIndividual> inds, int id){
		for(IIndividual ind: inds){
			if(((RankingIndividual)ind).getId() == id)
				return ind;
		}
		return null;
	}

	/**
	 * Replacement strategy: best individuals
	 * @return Best individuals between parents and sons
	 * */
	private List<IIndividual> betterIndividuals(){

		List<IIndividual> betters = null;
		int numInvalids = this.getNumberOfInvalids();

		ISelector selector = new BettersSelector();
		selector.contextualize(this);

		// All parents are invalid, then all descendants survive
		if(numInvalids == this.populationSize)
			betters = this.cset;

		// Some invalids, select valid solutions between valid parents and valid descendants
		// The rest is completed with invalid descendants (randomly selected)
		else if (numInvalids > 0){

			List<IIndividual> auxset = new ArrayList<IIndividual>();
			List<IIndividual> invalids = new ArrayList<IIndividual>();

			// Copy valid individuals
			for(IIndividual ind: this.bset){
				if(!((Cl2CmpIndividual)ind).isInvalid())
					auxset.add(ind);
			}
			// Copy descendants
			for(IIndividual ind: this.cset){
				if(!((Cl2CmpIndividual)ind).isInvalid())
					auxset.add(ind);
				else
					invalids.add(ind);
			}

			// Add betters between valid individuals
			if(auxset.size() > this.populationSize){	// Select some of auxset
				betters = selector.select(auxset, this.populationSize);
			}
			else{	// Add all in auxset and some invalid descendants
				betters = new ArrayList<IIndividual>();
				betters.addAll(auxset);

				ISelector randomSelector = new RandomSelector();
				randomSelector.contextualize(this);
				betters.addAll(randomSelector.select(invalids,(this.populationSize-auxset.size()),true));
			}	
		}
		// All valids, select between bset and cset
		else{
			List<IIndividual> allSet = new ArrayList<IIndividual>(this.cset);
			allSet.addAll(this.bset);
			betters = selector.select(allSet, this.populationSize);
		}

		return betters;
	}

	/**
	 * Replacement strategy: competition between each parent and son
	 * @return Best individuals comparing each parent and son
	 *  */
	private List<IIndividual> parentSonCompetition(){

		// First, Select best individual in the actual population
		List<IIndividual> auxset = new ArrayList<IIndividual>();
		ISelector bettersSelector = new BettersSelector();
		bettersSelector.contextualize(this);
		auxset.addAll(bettersSelector.select(this.bset, 1));

		IFitness fitness1, fitness2;
		IIndividual parent, offspring;

		for(int i=0; i<this.populationSize; i++){
			// Get parent
			parent = this.pset.get(i);
			fitness1 = parent.getFitness();

			// Get correspondent offspring because cset has been reordered
			offspring = this.cset.get(i);
			fitness2 = offspring.getFitness();

			// Compare fitness, the best between parent and son is added to the next generation
			// Parent has better fitness
			if(getEvaluator().getComparator().compare(fitness1, fitness2)>0){
				auxset.add(parent);
			}
			// Offsprings has better or equal fitness
			else{
				auxset.add(offspring);
			}
		}
		return bettersSelector.select(auxset,this.populationSize);
	}

	/**
	 * Replacement strategy: select best n individuals between actual individuals
	 * and, then, complete population with best descendants.
	 * @return N best parents and (Size-N) best sons 
	 * */
	private List<IIndividual> elitismBestSons(int n){
		List<IIndividual> auxset = new ArrayList<IIndividual>();

		ISelector betters = new BettersSelector();
		betters.contextualize(this);

		auxset.addAll(betters.select(this.bset, n));
		auxset.addAll(betters.select(this.cset, (this.populationSize-n)));
		return auxset;
	}

	/**
	 * Replacement strategy: binary tournament
	 * @return Result of binary tournament (repeat allowed) 
	 * between all individuals
	 * */
	private List<IIndividual> binaryTournament(){

		// Copy individuals
		List<IIndividual> auxset = new ArrayList<IIndividual>();
		List<IIndividual> allset = new ArrayList<IIndividual>(this.cset);
		allset.addAll(this.bset);

		// First, Select best individual
		ISelector bettersSelector = new BettersSelector();
		bettersSelector.contextualize(this);
		auxset.addAll(bettersSelector.select(allset, 1));

		// Tournament selector
		ISelector tournament = new TournamentSelector(); // Binary by defect
		tournament.contextualize(this);
		auxset.addAll(tournament.select(allset, this.populationSize-1, true));
		return auxset;
	}
}