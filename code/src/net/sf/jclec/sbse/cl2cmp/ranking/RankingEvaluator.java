package net.sf.jclec.sbse.cl2cmp.ranking;

import java.io.IOException;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import net.sf.jclec.IConfigure;
import net.sf.jclec.IEvaluator;
import net.sf.jclec.IFitness;
import net.sf.jclec.IIndividual;
import net.sf.jclec.fitness.SimpleValueFitness;
import net.sf.jclec.fitness.ValueFitnessComparator;
import net.sf.jclec.sbse.cl2cmp.ranking.metrics.*;
import net.sf.jclec.syntaxtree.SyntaxTree;

import org.apache.commons.configuration.Configuration;

import es.uco.kdis.datapro.dataset.Dataset;
import es.uco.kdis.datapro.dataset.Column.MultivalueColumn;
import es.uco.kdis.datapro.dataset.Source.CsvDataset;
import es.uco.kdis.datapro.exception.IllegalFormatSpecificationException;
import es.uco.kdis.datapro.exception.NotAddedValueException;

/**
 * Ranking aggregation fitness evaluator
 * for the 'Class to Components' (CL2CMP) problem.
 * 
 * <p>IEvaluator is implemented (instead of extend AbstractEvaluator)
 * because all individuals are evaluated together in order to assign rankings.
 * 
 * <p>History:
 * <ul>
 * 	<li>1.0: Creation (July 2013)
 * </ul>
 * 
 * @author Aurora Ramirez Quesada
 * @author Jose Raul Romero
 * @author Sebastian Ventura
 * @version 1.0
 * */

public class RankingEvaluator implements IEvaluator, IConfigure {

	//////////////////////////////////////////////////////////////////
	//----------------------------------------------------- Properties
	//////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	private static final long serialVersionUID = 6290684375978350592L;

	/** Number of evaluations */
	protected int numberOfEvaluations = 0;

	/** Execution time */
	public long executionTime = 0;

	/** Dataset storing information about relations */
	private Dataset dataset;

	/** Number of classes */
	private int numberOfClasses;

	/** Fitness comparator */	
	protected transient ValueFitnessComparator comparator;

	/** Selected metrics according to <code>Metrics</code> enumeration */
	private BitSet selectedMetrics;

	/** List of metrics used in evaluation to assign rankings */
	private transient ArrayList<CmpMetric> metrics;

	// For group discovery

	/** Array with the indexes of classes in a component  */
	private transient ArrayList<Integer> indexes = new ArrayList<Integer>();

	/** Array of nodes visited used the graph depth function  */
	private transient boolean visited [];

	/** Classes and its correspondent group inside the component */
	private transient int classGroup [];

	/** Fitness for invalid individuals: great ranking +1 */
	private double invalidFitness;
	
	// Verbose: dataset name
	private String datasetFile;
	
	//////////////////////////////////////////////////////////////////
	//--------------------------------------------------- Constructors
	//////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor.
	 * */
	public RankingEvaluator(){
		super();
		// Initialize comparator
		this.comparator = new ValueFitnessComparator(true);
	}

	//////////////////////////////////////////////////////////////////
	//----------------------------------------------- Override methods
	//////////////////////////////////////////////////////////////////

	@Override
	public void configure(Configuration settings) {

		// Set dataset
		this.datasetFile = settings.getString("model.path");
		int numberOfClasses = settings.getInt("model.num-of-classes");
		if(datasetFile!=null){
			try {
				setDataset(datasetFile,numberOfClasses);
			} catch (IndexOutOfBoundsException e) {
				e.printStackTrace();
			} catch (IOException e) {
				e.printStackTrace();
			} catch (NotAddedValueException e) {
				e.printStackTrace();
			} catch (IllegalFormatSpecificationException e) {
				e.printStackTrace();
			}
		}
		else{
			System.err.println("A dataset must be specified");
		}

		// Set selected metrics
		try{
			setSelectedMetrics(settings.subset("design-metric"));
		}catch(Exception e){
			System.err.println("Error during metric instantiation");
			e.printStackTrace();
		}

		// Check that, at least, one metrics has been selected
		if(this.metrics.size()==0){
			System.err.println("At least one metric must be selected");
			System.exit(-1);
		}

		// Configure parameters in metrics if necessary
		for(CmpMetric m: this.metrics){
			m.setDataset(this.dataset);
			m.configure(settings);
		}
	}

	@Override
	public Comparator<IFitness> getComparator() {
		return this.comparator;
	}

	@Override
	public void evaluate(List<IIndividual> inds) {
		
		long time = System.currentTimeMillis();

		// Compute needed measures (only for new individuals)
		for(IIndividual ind: inds){
			if (ind.getFitness() == null)
				computeMeasures(ind);
		}

		// Compute metrics (only for new individuals)
		for(IIndividual ind: inds){
			if (ind.getFitness() == null){
				computeMetrics(ind);
				this.numberOfEvaluations++;
			}
		}

		// Set rankings (in all individuals)
		computeRankings(inds);

		// Set fitness: aggregation rankings (in all individuals)
		for(IIndividual ind: inds){
			setFitness(ind);
		}

		this.executionTime += System.currentTimeMillis() - time;
	}

	@Override
	public int getNumberOfEvaluations() {
		return this.numberOfEvaluations;
	}

	//////////////////////////////////////////////////////////////////
	//------------------------------------------------- Public methods
	//////////////////////////////////////////////////////////////////

	/**
	 * Open and read the dataset
	 * @param path: Path to dataset file
	 * @param classes: Number of classes
	 * @throws IllegalFormatSpecificationException 
	 * */
	public void setDataset(String path, int classes) 
			throws IndexOutOfBoundsException, IOException, NotAddedValueException, IllegalFormatSpecificationException {
		this.numberOfClasses = classes;
		this.dataset = new CsvDataset(path);
		this.dataset.setMissingValue("?");
		String format = "";
		for(int i=0; i<classes; i++){
			format += "m";
		}
		((CsvDataset)this.dataset).readDataset("nv", format);
	}

	/** 
	 * Get the array of configured metrics
	 * @return The metrics array
	 **/
	public ArrayList<CmpMetric> getMetrics(){
		return this.metrics;
	}
	
	/**
	 * Get selected metrics
	 * @return The selected metrics
	 * */
	public BitSet getSelectedMetrics(){
		return this.selectedMetrics;
	}
	
	/**
	 * Set invalid fitness
	 * @param size: Population size
	 * */
	public void setInvalidFitness(int size){
		// Set invalid fitness
		this.invalidFitness = (this.metrics.size()) * size +1;
		// TODO Si ranking doble metricsSize+1
		//this.invalidFitness = (this.metrics.size()+1) * size +1;
	}
	
	/**
	 * Get invalid fitness
	 * */
	public double getInvalidFitness(){
		return this.invalidFitness;
	}
	
	/**
	 * Get dataset file name
	 * @return dataset file name
	 * */
	public String getDatasetFileName(){
		return this.datasetFile;
	}
	
	//////////////////////////////////////////////////////////////////
	//------------------------------------------------ Private methods
	//////////////////////////////////////////////////////////////////

	/**
	 * Configure evaluation metrics
	 * @param settings: Configuration
	 * @throws ClassNotFoundException 
	 * @throws IllegalAccessException 
	 * @throws InstantiationException 
	 * */
	@SuppressWarnings("unchecked")
	private void setSelectedMetrics(Configuration settings) throws ClassNotFoundException, InstantiationException, IllegalAccessException{
		// Set if the metric is used or not
		int numOfMetrics = Metrics.values().length;
		this.selectedMetrics =  new BitSet(numOfMetrics);

		String metricName;
		int pos;
		int metricIndex;

		// Get selected metrics
		for(int i=0; i<numOfMetrics; i++){
			metricName = Metrics.values()[i].name();
			pos = Metrics.values()[i].ordinal();
			this.selectedMetrics.set(pos,settings.getBoolean(metricName,false));
		}

		// Create list of metrics to be evaluated
		this.metrics = new ArrayList<CmpMetric>(this.selectedMetrics.cardinality());
		metricIndex = this.selectedMetrics.nextSetBit(0);
		while(metricIndex != -1){
			// Get metric to be evaluated
			metricName = Metrics.values()[metricIndex].name();
			Class<? extends CmpMetric> metricClass = 
					(Class<? extends CmpMetric>) Class.forName(CmpMetric.path + metricName);

			// Create a metric instance
			CmpMetric m = metricClass.newInstance();
			this.metrics.add(m);
			metricIndex = this.selectedMetrics.nextSetBit(metricIndex+1);
		}
	}

	/**
	 * Compute general measures over an individual
	 * @param ind: The individual
	 * */
	protected void computeMeasures(IIndividual ind){
		// Set required information for compute metrics
		this.setClassesDistribution(ind);
		this.setClassesInGroupsDistribution(ind);
		this.setNumberExternalRelations(ind);
	}

	/**
	 * Compute each configured metric over an individual
	 * @param ind: The individual
	 * */
	protected void computeMetrics(IIndividual ind){
		// Compute configured metrics
		for(CmpMetric metric: this.metrics){
			// Execute metric
			metric.prepare((RankingIndividual)ind);
			metric.calculate((RankingIndividual)ind);
			metric.setOnIndividual((RankingIndividual)ind);
		}
	}

	/**
	 * Compute the rankings for each metric
	 * in each individual
	 * @param inds: List of individuals
	 * */
	private void computeRankings(List<IIndividual> inds){
		int metricIndex = this.selectedMetrics.nextSetBit(0);	// The position of the metric in enumeration
		int ranking;
		double rankingValue, indValue;
		int numberOfInds = inds.size();
		// Order individual by each configured metric
		assert(metrics.size() == this.selectedMetrics.cardinality());

		for(CmpMetric metric: this.metrics){
			
			// Order individuals using the metric comparator
			Collections.sort(inds, metric.getComparator());
			
			// Set rankings
			ranking = 1;
			rankingValue = metric.getFromIndividual((RankingIndividual)inds.get(0));
			((RankingIndividual)inds.get(0)).setRanking(metricIndex, ranking);
			
			for(int i=1; i<numberOfInds; i++){
				indValue = metric.getFromIndividual((RankingIndividual)inds.get(i));
				// New value, increment ranking (otherwise, same ranking will be assigned)
				if(indValue!=rankingValue){
					ranking++;
					rankingValue = indValue;
				}
				((RankingIndividual)inds.get(i)).setRanking(metricIndex, ranking);
			}
			
			metricIndex = this.selectedMetrics.nextSetBit(metricIndex+1);
		}
	}

	/**
	 * Set the individual fitness as aggregation
	 * of rankings
	 * @param ind: Individual
	 * */
	private void setFitness(IIndividual ind){
		double ranking;
		// Invalid individual, set invalid fitness
		if(((RankingIndividual)ind).isInvalid()){
			ind.setFitness(new SimpleValueFitness(this.invalidFitness));
		}
		// Valid individual, set aggregation of rankings
		else{
			double fitness = 0.0;
			int metricIndex = this.selectedMetrics.nextSetBit(0);
			
			while(metricIndex!=-1){
				// Get ranking for the metric
				ranking = ((RankingIndividual)ind).getRanking(metricIndex);
				// TODO Doble ranking ICD
				/*if(metrics.get(metricIndex) instanceof ICD){
					fitness += ranking*ranking;
				}
				else{*/
					fitness += ranking;
				//}
				// Next metric
				metricIndex = this.selectedMetrics.nextSetBit(metricIndex+1);
			}
			ind.setFitness(new SimpleValueFitness(fitness));
		}
	}

	/** 
	 * Set the correspondence between each class and its component 
	 * @param ind: The individual
	 * */
	private void setClassesDistribution(IIndividual ind){

		int actualCmp=-1, index;
		boolean isClass = false, isConnector = false;
		String symbol;
		// Number of classes in each component
		int componentNumClasses [] = new int[((RankingIndividual)ind).getNumberOfComponents()];

		// Component at each class belong
		int distribution [] = new int[this.numberOfClasses];
		SyntaxTree genotype = ((RankingIndividual)ind).getGenotype();

		for(int i=1; !isConnector; i++){

			symbol = genotype.getNode(i).getSymbol();

			// Non terminal node
			if(genotype.getNode(i).arity()!=0){
				// New set of classes
				if(symbol.equalsIgnoreCase("classes")){
					isClass=true;
					actualCmp++;
				}
				else if(symbol.equalsIgnoreCase("required-interfaces")){
					isClass=false;
				}
				else if(symbol.equalsIgnoreCase("connectors")){
					isConnector=true;
				}
			}
			// Terminal node
			else if(isClass){

				// Increment the component number of classes
				componentNumClasses[actualCmp]++;

				// Set the component at which the class belongs
				index = this.dataset.getIndexOfColumn(this.dataset.getColumnByName(symbol));
				distribution[index] = actualCmp;
			}
		}// end of tree route

		// Set distribution in the individual
		((RankingIndividual)ind).setClassesDistribution(distribution);
		((RankingIndividual)ind).setNumberOfClasses(componentNumClasses);
	}

	/**
	 * Set the classes/group correspondence in each component
	 * @param ind: The individual 
	 * */
	private void setClassesInGroupsDistribution(IIndividual ind){
		// Get genotype
		SyntaxTree genotype = ((RankingIndividual)ind).getGenotype();

		int numberOfComponents = ((RankingIndividual)ind).getNumberOfComponents();
		int numberOfClasses = this.dataset.getColumns().size();

		int classIndex, actualCmp=-1;
		boolean isClass = false, isConnector = false;
		MultivalueColumn column;
		String symbol;

		// Initialize
		this.classGroup = new int [numberOfClasses];
		int componentNumGroups[] = new int[numberOfComponents];

		// Compute metrics for each component in the individual
		for(int i=1; !isConnector; i++){

			symbol = genotype.getNode(i).getSymbol();

			// Non terminal node
			if(genotype.getNode(i).arity()!=0){
				// The symbol classes indicates the beginning of a 
				// group of classes in a component
				if(symbol.equalsIgnoreCase("classes")){
					isClass=true;
					actualCmp++;
					// New set of classes
					this.indexes.clear();
				}
				else if(symbol.equalsIgnoreCase("required-interfaces")){
					isClass=false;
					// End of component classes, compute the number of groups
					componentNumGroups[actualCmp] = this.numberOfGroups();
				}
				else if(symbol.equalsIgnoreCase("connectors")){
					isConnector=true;
				}
			}
			// Terminal node
			else if(isClass){

				// Get the dataset information about the class
				column = (MultivalueColumn) this.dataset.getColumnByName(symbol);
				classIndex = this.dataset.getIndexOfColumn(column);

				// Add the class index in the array of indexes
				this.indexes.add(classIndex);
			}
		}// end of tree route

		// Set on individual
		((RankingIndividual)ind).setClassesToGroups(this.classGroup);
		((RankingIndividual)ind).setNumberOfGroups(componentNumGroups);
	}

	/**
	 * Counts the number of external relations on each component
	 * @param ind: The individual
	 * */ 
	private void setNumberExternalRelations(IIndividual ind) {
		// Get genotype
		SyntaxTree genotype = ((RankingIndividual)ind).getGenotype();
		int numberOfComponents = ((RankingIndividual)ind).getNumberOfComponents();

		int j, actualIndex, classIndex, actualCmp=-1, otherCmp=-1;
		boolean isClass = false, isOtherClass = false, isConnector = false;
		MultivalueColumn column;
		int nav_ij, nav_ji;
		String symbol;

		// Initialize
		int componentNumberExternalConnections [] = new int[numberOfComponents];

		for(int i=0; i<numberOfComponents; i++){
			componentNumberExternalConnections[i] = 0;
		}

		// Compute needed metrics for each component
		for(int i=1; !isConnector; i++){

			symbol = genotype.getNode(i).getSymbol();

			// Non terminal node
			if(genotype.getNode(i).arity()!=0){
				// The symbol classes indicates the beginning of a new component
				if(symbol.equalsIgnoreCase("classes")){
					isClass=true;
					actualCmp++;
				}
				else if(symbol.equalsIgnoreCase("required-interfaces")){
					isClass=false;
				}
				else if(symbol.equalsIgnoreCase("connectors")){
					isConnector=true;
				}
			}

			// Terminal node
			else{
				// If the terminal is a class
				if(isClass){

					// Get the dataset information about the class
					column = (MultivalueColumn) this.dataset.getColumnByName(symbol);
					actualIndex = this.dataset.getIndexOfColumn(column);

					// Check the relations with classes belonging to other components
					otherCmp=actualCmp;			// Start in the actual component
					j=i+1;

					while(!(genotype.getNode(j).getSymbol().equalsIgnoreCase("connectors"))){

						// Search a class in the other component
						if((genotype.getNode(j-1).getSymbol().equalsIgnoreCase("classes"))){
							isOtherClass=true;
							otherCmp++;
						}

						if(isOtherClass){
							// Get relations between classes
							classIndex = this.dataset.getIndexOfColumn(this.dataset.getColumnByName(genotype.getNode(j).getSymbol()));
							ArrayList<Object> relations1 = (ArrayList<Object>) column.getMultiElement(classIndex);

							// Not an invalid value
							if(relations1.size()>1){

								ArrayList<Object> relations2 = (ArrayList<Object>)((MultivalueColumn)this.dataset.getColumn(classIndex)).getMultiElement(actualIndex);

								// Check type and navigation of each relation
								for(int k=1; k<relations1.size(); k+=2){

									nav_ij = Integer.parseInt((String)relations1.get(k));
									nav_ji = Integer.parseInt((String)relations2.get(k));

									// Not a candidate interface, because its a bidirectional relation
									if(nav_ij==nav_ji){
										componentNumberExternalConnections[actualCmp]++;
										componentNumberExternalConnections[otherCmp]++;
									}
								}
							}
							// End of classes in the other component
							if(genotype.getNode(j+1).arity()!=0){
								isOtherClass=false;
							}
						}
						j++;
					}
				}
			}
		}// end of tree route

		((RankingIndividual)ind).setExternalConnections(componentNumberExternalConnections);
	}

	/**
	 * Compute the number of connected component
	 * in the graph formed with the actual 
	 * <code>indexes</code>.
	 * @return Number of connected component
	 * */
	private int numberOfGroups() {
		int i, numOfGroups = 0;
		int size = this.indexes.size();
		this.visited = new boolean[size];

		for(i=0; i<size; i++)
			this.visited[i]=false;

		for(i=0; i<size; i++){
			if(!this.visited[i]){
				this.classGroup[this.indexes.get(i)]=numOfGroups; // Set group number
				numOfGroups++;
				graphDepthPath(i, this.indexes.get(i));
			}
		}
		return numOfGroups;
	}

	/**
	 * Realize a graph depth search marking 
	 * visited nodes.
	 * @param actualNode The node origin.
	 * @param classIndex The column index in the dataset for the origin node.
	 * */
	private void graphDepthPath(int actualNode, int classIndex){
		int j, size = this.visited.length;
		// Now, the node is visited
		this.visited[actualNode]=true;
		for(j=0; j<size; j++){
			// The node origin is connected with the node j, not visited yet, continue recursive depth search with j
			if( ((MultivalueColumn)this.dataset.getColumn(classIndex)).getMultiElement(this.indexes.get(j)).size() > 1
					&& !this.visited[j]){

				this.classGroup[this.indexes.get(j)]=this.classGroup[classIndex];	// Set its group number
				graphDepthPath(j, this.indexes.get(j));
			}
		}
	}
}
